
# 并发与线程

## 1. 基本概念

### 1.1. 进程、线程和协程

- 进程：程序执行时的一个实例，一个进程至少包含一个线程，同进程里多个线程可共享数据，不同进程之间切换代价大。
- 线程：CPU 调度的基本单位，线程上下文切换代价比进程小，是进程的一个实体。
- 协程：是一种用户态的轻量级线程，一个线程可包含多个协程。进程和线程都是同步，协程是异步。

### 1.2. 并行与并发

- 并行指多个事件在同一个时刻发生；并发指在某时刻只有一个事件在发生，某个时间段内由于 CPU 交替执行，可以发生多个事件。
- 并行没有对 CPU 资源的抢占；并发执行的线程需要对 CPU 资源进行抢占。
- 并行执行的线程之间不存在切换；并发操作系统会根据任务调度系统给线程分配线程的 CPU 执行时间，线程的执行会进行切换。

### 1.3. 并发编程存在的三个问题

先看原子性、可见性和有序性三个特性的说明：

- 原子性：一个操作中 cpu 不能中断，要么不执行，要么执行完成。
- 可见性：多线程访问变量，一个线程修改了变量，其他线程能够立即看到修改值。
- 有序性：按照代码顺序执行。

再看下面在并发编程下无法保证三特性成立的情况以及解决方法。

#### 1.3.1. 原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。

#### 1.3.2. 可见性
可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

三种实现可见性的方式：
- volatile，一个线程修改了被 volatile 修饰的变量，新值对其他线程来说是立即可见的。

- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。

- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

#### 1.3.3. 有序性
有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

### 1.4. 先行发生原则（happens-before）
上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。

**单一线程原则**  Single Thread Rule  
在一个线程内，在程序前面的操作先行发生于后面的操作。

**管程锁定规则**  Monitor Lock Rule  
一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

**volatile 变量规则**  Volatile Variable Rule  
对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

**线程启动规则**  Thread Start Rule  
Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

**线程加入规则**  Thread Join Rule  
Thread 对象的结束先行发生于 join() 方法返回。

**线程中断规则**  Thread Interruption Rule  
对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

**对象终结规则**  Finalizer Rule  
一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

**传递性**  Transitivity  
如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。